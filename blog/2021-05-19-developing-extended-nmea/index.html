<!DOCTYPE html><html  data-capo=""><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Developing extended-nmea | Ricardo Boss</title>
<style>body,html{margin:0;padding:0}body{background:#222;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;font-size:.9rem;letter-spacing:.02em;line-height:1.5}a,body{font-weight:400}a{color:#32aa66;text-decoration:underline;text-decoration-color:currentColor;text-decoration-style:dotted;text-decoration-thickness:.01em;text-underline-offset:.15em}a:hover{text-decoration-style:solid}hr{border:0;border-top:1px solid #404040;margin:1.5em 0}pre{background:#151515;border-radius:1em;font-size:.9em;line-height:1.5;overflow-x:auto;padding:1em}::-webkit-scrollbar{height:.5em;width:.5em}::-webkit-scrollbar-track{background:#222}::-webkit-scrollbar-thumb{background:#3c3c3c;border-radius:5px}</style>
<style>.fade-down-enter-active[data-v-45459ebe],.fade-down-leave-active[data-v-45459ebe]{transition:all .3s ease-in-out}.fade-down-enter-from[data-v-45459ebe],.fade-down-leave-to[data-v-45459ebe]{opacity:0;transform:translateY(1em) scale(.5)}</style>
<style>body[data-v-dd509ce1],html[data-v-dd509ce1]{margin:0;padding:0}body[data-v-dd509ce1]{background:#222;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;font-size:.9rem;letter-spacing:.02em;line-height:1.5}a[data-v-dd509ce1],body[data-v-dd509ce1]{font-weight:400}a[data-v-dd509ce1]{color:#32aa66;text-decoration:underline;text-decoration-color:currentColor;text-decoration-style:dotted;text-decoration-thickness:.01em;text-underline-offset:.15em}a[data-v-dd509ce1]:hover{text-decoration-style:solid}hr[data-v-dd509ce1]{border:0;border-top:1px solid #404040;margin:1.5em 0}pre[data-v-dd509ce1]{background:#151515;border-radius:1em;font-size:.9em;line-height:1.5;overflow-x:auto;padding:1em}[data-v-dd509ce1]::-webkit-scrollbar{height:.5em;width:.5em}[data-v-dd509ce1]::-webkit-scrollbar-track{background:#222}[data-v-dd509ce1]::-webkit-scrollbar-thumb{background:#3c3c3c;border-radius:5px}aside[data-v-dd509ce1]{padding:1em}#sticky-wrapper[data-v-dd509ce1]{align-items:center;display:flex;flex-direction:column;gap:2em;position:sticky;top:1em}#picture[data-v-dd509ce1]{border:2px solid #32aa66;border-radius:50%;height:auto;max-width:90%;min-width:100px;width:40dvh}#info[data-v-dd509ce1]{align-items:center;display:flex;flex-direction:column;gap:.25em}#info[data-v-dd509ce1] :nth-child(2){font-size:2em}#info[data-v-dd509ce1] :nth-child(4){font-size:1.3em}</style>
<style>body[data-v-c0f255a7],html[data-v-c0f255a7]{margin:0;padding:0}body[data-v-c0f255a7]{background:#222;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;font-size:.9rem;letter-spacing:.02em;line-height:1.5}a[data-v-c0f255a7],body[data-v-c0f255a7]{font-weight:400}a[data-v-c0f255a7]{color:#32aa66;text-decoration:underline;text-decoration-color:currentColor;text-decoration-style:dotted;text-decoration-thickness:.01em;text-underline-offset:.15em}a[data-v-c0f255a7]:hover{text-decoration-style:solid}hr[data-v-c0f255a7]{border:0;border-top:1px solid #404040;margin:1.5em 0}pre[data-v-c0f255a7]{background:#151515;border-radius:1em;font-size:.9em;line-height:1.5;overflow-x:auto;padding:1em}[data-v-c0f255a7]::-webkit-scrollbar{height:.5em;width:.5em}[data-v-c0f255a7]::-webkit-scrollbar-track{background:#222}[data-v-c0f255a7]::-webkit-scrollbar-thumb{background:#3c3c3c;border-radius:5px}nav[data-v-c0f255a7]{align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end;padding:1rem 1rem 0 0}nav[data-v-c0f255a7]>*{border-radius:.5rem;margin-left:-.5rem;padding:.5rem 1rem;text-decoration:none;transition:background .1s ease-out;white-space:nowrap}nav>.router-link-active[data-v-c0f255a7]{background:#32aa66!important;color:#222}nav[data-v-c0f255a7]>:hover{background:rgba(50,170,102,.15)}</style>
<style>footer[data-v-649bd932]{align-items:center;display:flex;height:5dvh;justify-content:center;margin:4em 0;opacity:.5}</style>
<style>#default-layout{display:grid;grid-template:"navbar" auto "content" minmax(100dvh,1fr) "footer" auto/1fr;margin:0 auto;max-width:100%;width:100%}@media (min-width:800px){#default-layout{grid-template:"sidepanel navbar " auto "sidepanel content" minmax(100dvh,1fr) "sidepanel footer" auto/300px 1fr;max-width:1000px}#default-layout #sidepanel{display:block}}@media (min-width:1200px){#default-layout{max-width:1200px}}@media (min-width:1600px){#default-layout{max-width:1600px}}#sidepanel{display:none;grid-area:sidepanel}#navbar{grid-area:navbar}#content{grid-area:content;min-width:0;padding-left:1em;padding-right:1em}#footer{grid-area:footer}.page-enter-active,.page-leave-active{transition:all .15s}.page-enter-from,.page-leave-to{opacity:0;transform:translateX(.5em)}</style>
<style>#title[data-v-c4d89a65]{font-size:3em;font-weight:300;margin-bottom:.25em;margin-top:.5em}#date[data-v-c4d89a65]{font-size:.8em;opacity:.5}#article-content[data-v-c4d89a65]{font-size:1.2em;font-weight:300;letter-spacing:.03em;line-height:1.85;margin:0 auto;max-width:80ch}</style>
<style>pre code .line{display:block;min-height:1rem}</style>
<link rel="stylesheet" href="/_nuxt/entry.BDAgUsrc.css">
<link rel="stylesheet" href="/_nuxt/ProsePre.CchFRBtv.css">
<link rel="preload" as="fetch" crossorigin="anonymous" href="/blog/2021-05-19-developing-extended-nmea/_payload.json?86793bdd-3786-4fa5-80ef-5a3e6cefaf0b">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/D2cMEJSA.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Cz-pgpcP.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/bAnuBpqA.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/BdPEdhfj.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/B2iMqF2R.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/C-v3KzvZ.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/0mA3a77b.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/giCX83ce.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/_qJXvj-K.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Dekxaq6_.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/D23iN_Ik.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CYZV0mlb.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/RaHIF5I7.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/SXNnNMzt.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Cp6kirG2.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/C7HL335W.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/J-fjncbm.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DXM1NUOa.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/xkSsK3H_.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CoHNwwSF.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/CoZoEh7n.js">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/Czeh2itW.js">
<link rel="prefetch" as="image" type="image/png" href="/_nuxt/ricardo-boss-2023.square.min.HpIOziE9.png">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/BvxvR0e6.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/CVG1AIA6.js">
<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="me" href="https://phpc.social/@ricardoboss">
<meta property="og:title" content="Developing extended-nmea">
<meta name="description" content="These are some insights into the development of a node package called extended-nmea, which decodes a stream of text from a protocol called NMEA0183 into objects. Written in TypeScript.">
<meta property="og:description" content="These are some insights into the development of a node package called extended-nmea, which decodes a stream of text from a protocol called NMEA0183 into objects. Written in TypeScript.">
<script type="module" src="/_nuxt/D2cMEJSA.js" crossorigin></script></head><body><div id="__nuxt"><div id="default-layout"><aside id="sidepanel" data-v-dd509ce1><div id="sticky-wrapper" data-v-dd509ce1><img alt="Ricardo Boss 20231" src="/_nuxt/ricardo-boss-2023.square.min.HpIOziE9.png" id="picture" data-v-dd509ce1><div id="info" data-v-dd509ce1><span data-v-dd509ce1>Hi, I&#39;m</span><span data-v-dd509ce1>Ricardo Boss</span><span data-v-dd509ce1>a</span><span data-v-dd509ce1 data-v-45459ebe>Software Developer</span></div></div></aside><nav id="navbar" data-v-c0f255a7><a href="/blog" class="" data-v-c0f255a7>Blog</a><a href="/curriculum-vitae" class="" data-v-c0f255a7>Curriculum Vitae</a><a href="/projects" class="" data-v-c0f255a7>Projects</a><a href="/portfolio" class="" data-v-c0f255a7>Portfolio</a><a href="/uses" class="" data-v-c0f255a7>Uses</a><a href="/contact" class="" data-v-c0f255a7>Contact</a></nav><div id="content"><main data-v-c4d89a65><!--[--><a href="/blog" class="" data-v-c4d89a65>« Back to overview</a><article data-v-c4d89a65><h1 id="title" data-v-c4d89a65>Developing extended-nmea</h1><div id="date" data-v-c4d89a65> Created at 5/19/2021</div><div id="article-content" data-v-c4d89a65><h2 id="extended-nmea"><a href="#extended-nmea"><!--[-->extended-nmea<!--]--></a></h2><p><!--[-->So what is this library <a href="https://npmjs.com/package/extended-nmea" rel="nofollow"><!--[--><code class=""><!--[-->extended-nmea<!--]--></code><!--]--></a>? In short, it is a TypeScript library containing a Decoder, and a class for
every &quot;sentence&quot; in the NMEA0183 protocol. Each &quot;sentence&quot; is some data in a specific format, which is sent by GPS
trackers, temperature sensors and many other things, but mainly sensors.<!--]--></p><h2 id="nmea0183"><a href="#nmea0183"><!--[-->NMEA0183<!--]--></a></h2><p><!--[--><a href="https://www.nmea.org/" rel="nofollow"><!--[-->NMEA<!--]--></a>, short for &quot;National Marine Electronics Association&quot;, is an association from the USA which &quot;is committed to
enhancing the technology and safety of marine electronics through installer training and interface standards&quot;.
One of these standards is NMEA0183. If you want to purchase the latest version of their standard definition, you can
buy one on their site. If you aren&#39;t working with it professionally, I would not recommend buying it, since there are
enough reverse-engineered documentations available online (I even added two to the extended-nmea repository to ease
development).<!--]--></p><h3 id="the-protocol"><a href="#the-protocol"><!--[-->The Protocol<!--]--></a></h3><p><!--[-->The protocol itself is pretty simple. I will skip the physical part of the protocol, which involves connecting wires in
a specific way and go directly to the textual representation.<!--]--></p><p><!--[-->The basic concept to grasp is what a &quot;sentence&quot; is. A sentence always begins with the <code class=""><!--[-->$<!--]--></code> character and always ends with
<code class=""><!--[-->&lt;CR&gt;&lt;LF&gt;<!--]--></code> (a windows-style line ending). They are always made up of printable ASCII characters and should not be more
than 80 characters in length.<!--]--></p><p><!--[-->Next, we define three different sentence types:<!--]--></p><ul><!--[--><li><!--[-->Talker Sentence: always the same format, sent by a sensor containing data and status information<!--]--></li><li><!--[-->Query Sentence: always the same format, sent by a receiver to request specific data from a talker<!--]--></li><li><!--[-->Proprietary Sentence: data format and contents defined by third-party<!--]--></li><!--]--></ul><h4 id="talker-sentences"><a href="#talker-sentences"><!--[-->Talker Sentences<!--]--></a></h4><p><!--[-->A talker sentence always begins with &quot;$&quot; followed by the talker ID and then the sentence ID. The talker ID is always two
characters and the sentence ID always three characters in length. Following this &quot;header&quot; is a list of fields, separated
by commas. The number of fields varies by sentence ID. Some sentences need more than 80 characters, so they dedicate the
first two fields to a &quot;page&quot; and &quot;total pages&quot; type of information (can be seen in GSV for example).
After this list, a &quot;*&quot; character followed by a checksum is appended. The newline ends the sentence.<!--]--></p><!--[--><pre class="" style=""><!--[--><code>$AABBB,CCC,123,...*XX&lt;CR&gt;&lt;LF&gt;
</code><!--]--></pre><!--]--><p><!--[-->In this example, <code class=""><!--[-->AA<!--]--></code> is the talker ID, <code class=""><!--[-->BBB<!--]--></code> is the sentence ID, <code class=""><!--[-->CCC,123,...<!--]--></code> are the data fields and <code class=""><!--[-->XX<!--]--></code> is the
checksum.<!--]--></p><p><!--[-->The checksum is a simple XOR-checksum for every character between &quot;$&quot; and &quot;*&quot;, excluding both. This is a code snippet
from the library, which implements this checksum calculation in Typescript (<a href="https://github.com/ricardoboss/extended-nmea/blob/70915a762d1b71678c272a73027480712f33fda0/src/helpers.ts#L10" rel="nofollow"><!--[-->permalink<!--]--></a>):<!--]--></p><!--[--><pre class="language-typescript shiki shiki-themes github-dark" style=""><!--[--><code><span class="line" line="1"><span style="--shiki-default:#F97583">function</span><span style="--shiki-default:#B392F0"> xorChecksum</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#FFAB70">data</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#79B8FF"> string</span><span style="--shiki-default:#E1E4E8">)</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#B392F0"> Uppercase</span><span style="--shiki-default:#E1E4E8">&lt;</span><span style="--shiki-default:#79B8FF">string</span><span style="--shiki-default:#E1E4E8">&gt; {
</span></span><span class="line" line="2"><span style="--shiki-default:#F97583">  if</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#F97583">typeof</span><span style="--shiki-default:#E1E4E8"> data </span><span style="--shiki-default:#F97583">!==</span><span style="--shiki-default:#9ECBFF"> &quot;string&quot;</span><span style="--shiki-default:#E1E4E8">)
</span></span><span class="line" line="3"><span style="--shiki-default:#F97583">    throw</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> TypeError</span><span style="--shiki-default:#E1E4E8">(
</span></span><span class="line" line="4"><span style="--shiki-default:#9ECBFF">      `Cannot use arguments of type &#39;${</span><span style="--shiki-default:#F97583">typeof</span><span style="--shiki-default:#E1E4E8"> data</span><span style="--shiki-default:#9ECBFF">}&#39; as input.`</span><span style="--shiki-default:#E1E4E8">,
</span></span><span class="line" line="5"><span style="--shiki-default:#E1E4E8">    )
</span></span><span class="line" line="6"><span emptylineplaceholder="true">
</span></span><span class="line" line="7"><span style="--shiki-default:#F97583">  let</span><span style="--shiki-default:#E1E4E8"> sum </span><span style="--shiki-default:#F97583">=</span><span style="--shiki-default:#79B8FF"> 0
</span></span><span class="line" line="8"><span style="--shiki-default:#F97583">  for</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#F97583">let</span><span style="--shiki-default:#E1E4E8"> i </span><span style="--shiki-default:#F97583">=</span><span style="--shiki-default:#79B8FF"> 0</span><span style="--shiki-default:#E1E4E8">; i </span><span style="--shiki-default:#F97583">&lt;</span><span style="--shiki-default:#E1E4E8"> data.</span><span style="--shiki-default:#79B8FF">length</span><span style="--shiki-default:#E1E4E8">; i</span><span style="--shiki-default:#F97583">++</span><span style="--shiki-default:#E1E4E8">) sum </span><span style="--shiki-default:#F97583">^=</span><span style="--shiki-default:#E1E4E8"> data.</span><span style="--shiki-default:#B392F0">charCodeAt</span><span style="--shiki-default:#E1E4E8">(i)
</span></span><span class="line" line="9"><span emptylineplaceholder="true">
</span></span><span class="line" line="10"><span style="--shiki-default:#F97583">  const</span><span style="--shiki-default:#79B8FF"> hex</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> sum.</span><span style="--shiki-default:#B392F0">toString</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#79B8FF">16</span><span style="--shiki-default:#E1E4E8">)
</span></span><span class="line" line="11"><span emptylineplaceholder="true">
</span></span><span class="line" line="12"><span style="--shiki-default:#6A737D">  // crude hack to pad with zeros
</span></span><span class="line" line="13"><span style="--shiki-default:#F97583">  return</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#9ECBFF">&quot;00&quot;</span><span style="--shiki-default:#F97583"> +</span><span style="--shiki-default:#E1E4E8"> hex).</span><span style="--shiki-default:#B392F0">slice</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#F97583">-</span><span style="--shiki-default:#79B8FF">2</span><span style="--shiki-default:#E1E4E8">).</span><span style="--shiki-default:#B392F0">toUpperCase</span><span style="--shiki-default:#E1E4E8">()
</span></span><span class="line" line="14"><span style="--shiki-default:#E1E4E8">}
</span></span></code><!--]--></pre><!--]--><p><!--[-->The resulting checksum will always consist of two hexadecimal uppercase characters.<!--]--></p><p><!--[-->What I wrote earlier about the talker and sentence ID lengths is not always true. Not every device out there in the
world strictly adheres to the protocol and may use more or less than three characters for the sentence ID (at least in
my experience). Therefore, the limit of 80 characters is also not as strict as the protocol indicates.<!--]--></p><h4 id="query-sentences"><a href="#query-sentences"><!--[-->Query Sentences<!--]--></a></h4><p><!--[-->A query sentence allows devices to request certain sentences (data) from other devices. It has a similar structure to
talker sentences:<!--]--></p><!--[--><pre class="" style=""><!--[--><code>$RRLLQ,BBB&lt;CR&gt;&lt;LF&gt;
</code><!--]--></pre><!--]--><p><!--[--><code class=""><!--[-->RR<!--]--></code> is the requester ID, <code class=""><!--[-->LL<!--]--></code> is the device being queried and <code class=""><!--[-->BBB<!--]--></code> is the mnemonic of the sentence being requested.
The fifth letter in a query sentence is always <code class=""><!--[-->Q<!--]--></code>. <code class=""><!--[-->BBB<!--]--></code> corresponds to the sentence ID in the talker sentence above.
As you can see, this sentence does not contain a checksum.<!--]--></p><h4 id="proprietary-sentences"><a href="#proprietary-sentences"><!--[-->Proprietary Sentences<!--]--></a></h4><p><!--[-->The proprietary sentences are a means to allow third-party developers to create their own sentence IDs or even data
formats, as long as they fit in the general format for NMEA0183.<!--]--></p><!--[--><pre class="" style=""><!--[--><code>$PMMM...&lt;CR&gt;&lt;LF&gt;
</code><!--]--></pre><!--]--><p><!--[-->Proprietary sentences always start with &quot;$P&quot;, followed by a three character manufacturer ID <code class=""><!--[-->MMM<!--]--></code>. Everything between this
header and the newline can be formatted however the manufacturer wants.<!--]--></p><h2 id="why-tho"><a href="#why-tho"><!--[-->Why tho<!--]--></a></h2><p><!--[-->The motivation behind this project arose when I wanted to create a web application, which parsed and then visualized
data provided in the NMEA0183 standard. After looking into some existing libraries, I forked <a href="https://github.com/jamesp/node-nmea" rel="nofollow"><!--[-->jamesp/node-nmea<!--]--></a> and
started tinkering with the code and even opened a <a href="https://github.com/jamesp/node-nmea/pull/24" rel="nofollow"><!--[-->pull request<!--]--></a>, which got accepted. In my fork, I originally just
wanted to clean up the code and maybe change some interfaces.<!--]--></p><p><!--[-->When I began my original project, I wanted to harness the power of type safety from TypeScript. Since <a href="https://github.com/jamesp/node-nmea" rel="nofollow"><!--[-->node-nmea<!--]--></a> was
not type safe, it didn&#39;t play well with the rest of the code. That&#39;s why I created this version, which is a
completely new implementation with the same idea, just with TypeScript support.<!--]--></p><p><!--[-->The library supports registering proprietary and talker sentences not already included, so you can start developing ASAP
with your use-case.<!--]--></p><p><!--[-->In the end, I created <a href="https://github.com/ricardoboss/vessel-state" rel="nofollow"><!--[-->ricardoboss/vessel-state<!--]--></a>, which uses this library to update a Vuex store&#39;s state,
representing a vessel with the latest information available.<!--]--></p><h2 id="starting-development"><a href="#starting-development"><!--[-->Starting Development<!--]--></a></h2><p><!--[-->I began by creating class definitions for NMEA sentences in general and the three different sub-types (talker, query,
proprietary). Then, I created the <code class=""><!--[-->Decoder<!--]--></code> class, which would later possess the functionality to match a string to a
registered sentence type and return a decoded version of it. I also wanted to keep the ability to add other sentences
later on. The original library (<a href="https://github.com/jamesp/node-nmea" rel="nofollow"><!--[--><code class=""><!--[-->node-nmea<!--]--></code><!--]--></a>) used a map with string keys, where the sentence ID is the key, and the
value is an object with a decoder function. I thought this was a good idea, so I re-used (stole) this idea. The
<code class=""><!--[-->Decoder<!--]--></code> class keeps a map for every sentence type to quickly filter it. <a href="https://github.com/ricardoboss/extended-nmea/blob/70915a762d1b71678c272a73027480712f33fda0/src/decoder.ts#L45" rel="nofollow"><!--[-->This method<!--]--></a> of the decoder class checks
which sentence type a string given to it has and passes it to a more-detailed decoder method:<!--]--></p><!--[--><pre class="language-typescript shiki shiki-themes github-dark" style=""><!--[--><code><span class="line" line="1"><span style="--shiki-default:#F97583">class</span><span style="--shiki-default:#B392F0"> Decoder</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="2"><span style="--shiki-default:#F97583">  public</span><span style="--shiki-default:#F97583"> static</span><span style="--shiki-default:#B392F0"> decode</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#FFAB70">data</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#79B8FF"> string</span><span style="--shiki-default:#E1E4E8">)</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#B392F0"> INmeaSentence</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="3"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#F97583">typeof</span><span style="--shiki-default:#E1E4E8"> data </span><span style="--shiki-default:#F97583">!==</span><span style="--shiki-default:#9ECBFF"> &quot;string&quot;</span><span style="--shiki-default:#E1E4E8">)
</span></span><span class="line" line="4"><span style="--shiki-default:#F97583">      throw</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> Error</span><span style="--shiki-default:#E1E4E8">(
</span></span><span class="line" line="5"><span style="--shiki-default:#9ECBFF">        `Unable to decode sentence: invalid data type: ${</span><span style="--shiki-default:#F97583">typeof</span><span style="--shiki-default:#E1E4E8"> data</span><span style="--shiki-default:#9ECBFF">}. Only strings are supported.`</span><span style="--shiki-default:#E1E4E8">,
</span></span><span class="line" line="6"><span style="--shiki-default:#E1E4E8">      )
</span></span><span class="line" line="7"><span emptylineplaceholder="true">
</span></span><span class="line" line="8"><span style="--shiki-default:#6A737D">    // check proprietary sentences first to prevent false positives
</span></span><span class="line" line="9"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (data.</span><span style="--shiki-default:#79B8FF">length</span><span style="--shiki-default:#F97583"> &gt;</span><span style="--shiki-default:#79B8FF"> 1</span><span style="--shiki-default:#F97583"> &amp;&amp;</span><span style="--shiki-default:#E1E4E8"> data[</span><span style="--shiki-default:#79B8FF">1</span><span style="--shiki-default:#E1E4E8">] </span><span style="--shiki-default:#F97583">===</span><span style="--shiki-default:#9ECBFF"> &quot;P&quot;</span><span style="--shiki-default:#E1E4E8">) {
</span></span><span class="line" line="10"><span style="--shiki-default:#F97583">      return</span><span style="--shiki-default:#79B8FF"> this</span><span style="--shiki-default:#E1E4E8">.</span><span style="--shiki-default:#B392F0">decodeProprietary</span><span style="--shiki-default:#E1E4E8">(data)
</span></span><span class="line" line="11"><span style="--shiki-default:#E1E4E8">    }
</span></span><span class="line" line="12"><span emptylineplaceholder="true">
</span></span><span class="line" line="13"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (data.</span><span style="--shiki-default:#79B8FF">length</span><span style="--shiki-default:#F97583"> &gt;</span><span style="--shiki-default:#79B8FF"> 5</span><span style="--shiki-default:#F97583"> &amp;&amp;</span><span style="--shiki-default:#E1E4E8"> data[</span><span style="--shiki-default:#79B8FF">5</span><span style="--shiki-default:#E1E4E8">] </span><span style="--shiki-default:#F97583">===</span><span style="--shiki-default:#9ECBFF"> &quot;Q&quot;</span><span style="--shiki-default:#E1E4E8">) {
</span></span><span class="line" line="14"><span style="--shiki-default:#F97583">      return</span><span style="--shiki-default:#79B8FF"> this</span><span style="--shiki-default:#E1E4E8">.</span><span style="--shiki-default:#B392F0">decodeQuery</span><span style="--shiki-default:#E1E4E8">(data)
</span></span><span class="line" line="15"><span style="--shiki-default:#E1E4E8">    }
</span></span><span class="line" line="16"><span emptylineplaceholder="true">
</span></span><span class="line" line="17"><span style="--shiki-default:#F97583">    return</span><span style="--shiki-default:#79B8FF"> this</span><span style="--shiki-default:#E1E4E8">.</span><span style="--shiki-default:#B392F0">decodeTalker</span><span style="--shiki-default:#E1E4E8">(data)
</span></span><span class="line" line="18"><span style="--shiki-default:#E1E4E8">  }
</span></span><span class="line" line="19"><span style="--shiki-default:#E1E4E8">}
</span></span></code><!--]--></pre><!--]--><p><!--[-->Each method has it&#39;s own way of parsing the given sentence. A query sentence for example will just invoke the
<code class=""><!--[-->QuerySentence<!--]--></code> constructor and all interpretation of the data is done in the getters. Proprietary and talker sentences
on the other hand need to be dynamic and receive a little more evaluation.<!--]--></p><p><!--[-->To instantiate a proprietary sentence, we first need to check if it has been registered in the decoder. The
<code class=""><!--[-->ProprietaryCodecs<!--]--></code> array contains the constructors registered by the user and are keyed by their identifier
(manufacturer id + sentence id). If the user expects a certain type, they can pass it as a generic parameter and enjoy
full type safety:<!--]--></p><!--[--><pre class="language-typescript shiki shiki-themes github-dark" style=""><!--[--><code><span class="line" line="1"><span style="--shiki-default:#F97583">class</span><span style="--shiki-default:#B392F0"> Decoder</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="2"><span style="--shiki-default:#F97583">  public</span><span style="--shiki-default:#F97583"> static</span><span style="--shiki-default:#B392F0"> decodeProprietary</span><span style="--shiki-default:#E1E4E8">&lt;</span><span style="--shiki-default:#B392F0">T</span><span style="--shiki-default:#F97583"> extends</span><span style="--shiki-default:#B392F0"> IProprietarySentence</span><span style="--shiki-default:#E1E4E8">&gt;(
</span></span><span class="line" line="3"><span style="--shiki-default:#FFAB70">    data</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#79B8FF"> string</span><span style="--shiki-default:#E1E4E8">,
</span></span><span class="line" line="4"><span style="--shiki-default:#E1E4E8">  )</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#B392F0"> T</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="5"><span style="--shiki-default:#F97583">    const</span><span style="--shiki-default:#79B8FF"> manufacturerId</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> data.</span><span style="--shiki-default:#B392F0">substr</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#79B8FF">2</span><span style="--shiki-default:#E1E4E8">, data.</span><span style="--shiki-default:#B392F0">indexOf</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&quot;,&quot;</span><span style="--shiki-default:#E1E4E8">) </span><span style="--shiki-default:#F97583">-</span><span style="--shiki-default:#79B8FF"> 2</span><span style="--shiki-default:#E1E4E8">)
</span></span><span class="line" line="6"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#F97583">!</span><span style="--shiki-default:#E1E4E8">Decoder.ProprietaryCodecs.</span><span style="--shiki-default:#B392F0">has</span><span style="--shiki-default:#E1E4E8">(manufacturerId))
</span></span><span class="line" line="7"><span style="--shiki-default:#F97583">      throw</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> Error</span><span style="--shiki-default:#E1E4E8">(
</span></span><span class="line" line="8"><span style="--shiki-default:#9ECBFF">        `Unable to decode sentence: unknown manufacturer id for proprietary sentence: ${</span><span style="--shiki-default:#E1E4E8">manufacturerId</span><span style="--shiki-default:#9ECBFF">}`</span><span style="--shiki-default:#E1E4E8">,
</span></span><span class="line" line="9"><span style="--shiki-default:#E1E4E8">      )
</span></span><span class="line" line="10"><span emptylineplaceholder="true">
</span></span><span class="line" line="11"><span style="--shiki-default:#F97583">    const</span><span style="--shiki-default:#79B8FF"> sentenceConstructor</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> Decoder.ProprietaryCodecs.</span><span style="--shiki-default:#B392F0">get</span><span style="--shiki-default:#E1E4E8">(manufacturerId)
</span></span><span class="line" line="12"><span style="--shiki-default:#F97583">    return</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> sentenceConstructor</span><span style="--shiki-default:#E1E4E8">(data, manufacturerId) </span><span style="--shiki-default:#F97583">as</span><span style="--shiki-default:#B392F0"> T
</span></span><span class="line" line="13"><span style="--shiki-default:#E1E4E8">  }
</span></span><span class="line" line="14"><span style="--shiki-default:#E1E4E8">}
</span></span></code><!--]--></pre><!--]--><p><!--[-->The <code class=""><!--[-->decodeTalker<!--]--></code> method uses the provided data to determine the talker ID and sentence ID. It then checks if the
talker ID and sentence ID are registered in the decoder. If they are, it instantiates the corresponding constructor
and returns it. Here too, the user can pass a generic parameter to the method to get full type safety:<!--]--></p><!--[--><pre class="language-typescript shiki shiki-themes github-dark" style=""><!--[--><code><span class="line" line="1"><span style="--shiki-default:#F97583">class</span><span style="--shiki-default:#B392F0"> Decoder</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="2"><span style="--shiki-default:#F97583">  public</span><span style="--shiki-default:#F97583"> static</span><span style="--shiki-default:#B392F0"> decodeTalker</span><span style="--shiki-default:#E1E4E8">&lt;</span><span style="--shiki-default:#B392F0">T</span><span style="--shiki-default:#F97583"> extends</span><span style="--shiki-default:#B392F0"> ITalkerSentence</span><span style="--shiki-default:#E1E4E8">&gt;(</span><span style="--shiki-default:#FFAB70">data</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#79B8FF"> string</span><span style="--shiki-default:#E1E4E8">)</span><span style="--shiki-default:#F97583">:</span><span style="--shiki-default:#B392F0"> T</span><span style="--shiki-default:#E1E4E8"> {
</span></span><span class="line" line="3"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (data.</span><span style="--shiki-default:#79B8FF">length</span><span style="--shiki-default:#F97583"> &lt;</span><span style="--shiki-default:#79B8FF"> 6</span><span style="--shiki-default:#E1E4E8">)
</span></span><span class="line" line="4"><span style="--shiki-default:#F97583">      throw</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> Error</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">`Unable to decode sentence: invalid format. Expected at least 6 characters, got: ${</span><span style="--shiki-default:#E1E4E8">data</span><span style="--shiki-default:#9ECBFF">} (${</span><span style="--shiki-default:#E1E4E8">data</span><span style="--shiki-default:#9ECBFF">.</span><span style="--shiki-default:#79B8FF">length</span><span style="--shiki-default:#9ECBFF">} characters)`</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="5"><span emptylineplaceholder="true">
</span></span><span class="line" line="6"><span style="--shiki-default:#F97583">    const</span><span style="--shiki-default:#79B8FF"> talkerIdLength</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#79B8FF"> 2</span><span style="--shiki-default:#E1E4E8">;
</span></span><span class="line" line="7"><span style="--shiki-default:#F97583">    const</span><span style="--shiki-default:#79B8FF"> sentenceId</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> data.</span><span style="--shiki-default:#B392F0">substr</span><span style="--shiki-default:#E1E4E8">(talkerIdLength </span><span style="--shiki-default:#F97583">+</span><span style="--shiki-default:#79B8FF"> 1</span><span style="--shiki-default:#E1E4E8">, data.</span><span style="--shiki-default:#B392F0">indexOf</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&#39;,&#39;</span><span style="--shiki-default:#E1E4E8">) </span><span style="--shiki-default:#F97583">-</span><span style="--shiki-default:#E1E4E8"> talkerIdLength </span><span style="--shiki-default:#F97583">-</span><span style="--shiki-default:#79B8FF"> 1</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="8"><span style="--shiki-default:#F97583">    if</span><span style="--shiki-default:#E1E4E8"> (</span><span style="--shiki-default:#F97583">!</span><span style="--shiki-default:#E1E4E8">Decoder.TalkerCodecs.</span><span style="--shiki-default:#B392F0">has</span><span style="--shiki-default:#E1E4E8">(sentenceId))
</span></span><span class="line" line="9"><span style="--shiki-default:#F97583">      throw</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> Error</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">`Unable to decode sentence: unknown sentence id: ${</span><span style="--shiki-default:#E1E4E8">sentenceId</span><span style="--shiki-default:#9ECBFF">}`</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="10"><span emptylineplaceholder="true">
</span></span><span class="line" line="11"><span style="--shiki-default:#F97583">    const</span><span style="--shiki-default:#79B8FF"> sentenceConstructor</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> Decoder.TalkerCodecs.</span><span style="--shiki-default:#B392F0">get</span><span style="--shiki-default:#E1E4E8">(sentenceId);
</span></span><span class="line" line="12"><span style="--shiki-default:#F97583">    return</span><span style="--shiki-default:#F97583"> new</span><span style="--shiki-default:#B392F0"> sentenceConstructor</span><span style="--shiki-default:#E1E4E8">(data, talkerIdLength) </span><span style="--shiki-default:#F97583">as</span><span style="--shiki-default:#B392F0"> T</span><span style="--shiki-default:#E1E4E8">;
</span></span><span class="line" line="13"><span style="--shiki-default:#E1E4E8">  }
</span></span><span class="line" line="14"><span style="--shiki-default:#E1E4E8">}
</span></span></code><!--]--></pre><!--]--><h2 id="tests"><a href="#tests"><!--[-->Tests<!--]--></a></h2><p><!--[-->For unit testing, I decided to use <a href="https://mochajs.org/" rel="nofollow"><!--[-->mocha<!--]--></a> and <a href="https://www.chaijs.com/" rel="nofollow"><!--[-->chai<!--]--></a> as I like their API. I won&#39;t go into the details of how to
write tests, but I will show you how to write a test for the <code class=""><!--[-->Decoder<!--]--></code> class:<!--]--></p><!--[--><pre class="language-typescript shiki shiki-themes github-dark" style=""><!--[--><code><span class="line" line="1"><span style="--shiki-default:#B392F0">describe</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&#39;Decoder&#39;</span><span style="--shiki-default:#E1E4E8">, </span><span style="--shiki-default:#F97583">function</span><span style="--shiki-default:#E1E4E8"> () {
</span></span><span class="line" line="2"><span style="--shiki-default:#B392F0">    it</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&#39;decodes talker sentences&#39;</span><span style="--shiki-default:#E1E4E8">, </span><span style="--shiki-default:#F97583">function</span><span style="--shiki-default:#E1E4E8">() {
</span></span><span class="line" line="3"><span style="--shiki-default:#F97583">        const</span><span style="--shiki-default:#79B8FF"> decoded</span><span style="--shiki-default:#F97583"> =</span><span style="--shiki-default:#E1E4E8"> Decoder.</span><span style="--shiki-default:#B392F0">decodeTalker</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&quot;$--ROT,-0.5,A*0E</span><span style="--shiki-default:#79B8FF">\r\n</span><span style="--shiki-default:#9ECBFF">&quot;</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="4"><span emptylineplaceholder="true">
</span></span><span class="line" line="5"><span style="--shiki-default:#B392F0">        expect</span><span style="--shiki-default:#E1E4E8">(decoded.valid).to.</span><span style="--shiki-default:#B392F0">equal</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#79B8FF">true</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="6"><span style="--shiki-default:#B392F0">        expect</span><span style="--shiki-default:#E1E4E8">(decoded.talkerId).to.</span><span style="--shiki-default:#B392F0">equal</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&quot;--&quot;</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="7"><span style="--shiki-default:#B392F0">        expect</span><span style="--shiki-default:#E1E4E8">(decoded.sentenceId).to.</span><span style="--shiki-default:#B392F0">equal</span><span style="--shiki-default:#E1E4E8">(</span><span style="--shiki-default:#9ECBFF">&quot;ROT&quot;</span><span style="--shiki-default:#E1E4E8">);
</span></span><span class="line" line="8"><span style="--shiki-default:#E1E4E8">    });
</span></span><span class="line" line="9"><span style="--shiki-default:#E1E4E8">});
</span></span></code><!--]--></pre><!--]--><p><!--[-->This just checks that the decoder can correctly parse a talker sentence and that the returned object has the correct
properties.<!--]--></p><p><!--[-->If you want to see more tests or tests for specific sentences, you can check out the <a href="https://github.com/ricardoboss/extended-nmea/tree/70915a762d1b71678c272a73027480712f33fda0/test" rel="nofollow"><!--[--><code class=""><!--[-->test<!--]--></code><!--]--></a> in the repository.<!--]--></p><h2 id="conclusion"><a href="#conclusion"><!--[-->Conclusion<!--]--></a></h2><p><!--[-->I hope this post has given you a better understanding of how the NMEA0183 protocol works and how to implement it in
TypeScript. I hope you find this library useful and that it helps you in your own projects. If you have any questions,
feel free to <a href="https://ricardoboss.de/contact" rel="nofollow"><!--[-->reach out to me<!--]--></a>.<!--]--></p><style>html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}</style></div></article><!--]--><a href="/blog" class="" data-v-c4d89a65>« Back to overview</a></main></div><footer id="footer" data-v-649bd932><p data-v-649bd932>© 2024 Ricardo Boss. All rights reserved.</p></footer></div></div><div id="teleports"></div><script type="application/json" id="__NUXT_DATA__" data-ssr="true" data-src="/blog/2021-05-19-developing-extended-nmea/_payload.json?86793bdd-3786-4fa5-80ef-5a3e6cefaf0b">[{"state":1,"once":3,"_errors":4,"serverRendered":7,"path":8,"prerenderedAt":9},["Reactive",2],{},["Set"],["ShallowReactive",5],{"content-query-6NIyYGPoPB":6},null,true,"/blog/2021-05-19-developing-extended-nmea",1718714186822]</script>
<script>window.__NUXT__={};window.__NUXT__.config={public:{mdc:{components:{prose:true,map:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"}},headings:{anchorLinks:{h1:false,h2:true,h3:true,h4:true,h5:false,h6:false}}},content:{locales:[],defaultLocale:"",integrity:1718714177677,experimental:{stripQueryParameters:false,advanceQuery:false,clientDB:false},respectPathCase:false,api:{baseURL:"/api/_content"},navigation:{fields:[]},tags:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"ProseCodeInline",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"},highlight:{theme:"github-dark",preload:["vue","javascript","typescript","bash","markdown","c#","yml","json","xml"],highlighter:"shiki",langs:["js","jsx","json","ts","tsx","vue","css","html","vue","bash","md","mdc","yaml","vue","javascript","typescript","bash","markdown","c#","yml","json","xml"]},wsUrl:"",documentDriven:false,host:"",trailingSlash:false,search:"",contentHead:true,anchorLinks:{depth:4,exclude:[1]}}},app:{baseURL:"/",buildId:"86793bdd-3786-4fa5-80ef-5a3e6cefaf0b",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script></body></html>